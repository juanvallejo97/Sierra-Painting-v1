<!doctype html>
<meta charset="utf-8" />
<title>Firebase Token Probe</title>
<pre id="out">Loading…</pre>
<script type="module">
  // ---- URL params ----
  const url = new URL(location.href);
  const email = url.searchParams.get("email") || "";
  const pass  = url.searchParams.get("pass")  || "";
  const siteKey = url.searchParams.get("recaptcha") || ""; // optional ?recaptcha=SITE_KEY
  const debugFlag = url.searchParams.get("debug") === 'true' || url.searchParams.get("debug") === '1';

  // ---- Firebase SDKs (v11) ----
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
  import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
  import { connectAuthEmulator } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js";
  import { initializeAppCheck, ReCaptchaV3Provider, getToken as getAppCheckToken } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app-check.js";

  // TODO: fill in your real config
  // Default embedded config (fallback). Prefer creating scripts/firebase_config.json with real values.
  const fallbackConfig = {
    apiKey: "AIzaSyAJizvq82-zsud2NLtp_AtiboIV7mn2WOs",
    authDomain: "your-project-id.firebaseapp.com",
    projectId: "to-do-app-ac602",
    appId: "1:138777646966:web:4d2b7855b2cb2b0c7e0c57",
    recaptcha: "6Lclq98rAAAAAHR8xPb6c8wYsk3BZ_K6g2ztur63"
  };

  // Attempt to load an explicit config file generated from .env: scripts/firebase_config.json
  async function loadFirebaseConfig() {
    try {
      const res = await fetch('/scripts/firebase_config.json', { cache: 'no-store' });
      if (res.ok) {
        const j = await res.json();
        console.log('Loaded firebase config from /scripts/firebase_config.json');
        return j;
      }
    } catch (e) {
      // ignore and fallback
    }
    console.log('Using embedded fallback firebaseConfig');
    return fallbackConfig;
  }

  const out = document.getElementById("out");
  const log = (msg) => { console.log(msg); out.textContent += (out.textContent ? "\n" : "") + msg; };

  try {
  out.textContent = "Initializing Firebase…";
  const firebaseConfig = await loadFirebaseConfig();
  const app = initializeApp(firebaseConfig);

    // ---- App Check ----
    let appCheck;
    if (firebaseConfig.useEmulators) {
      // When running against emulators, enable App Check debug mode so the validator
      // can observe an App Check token and print the expected phrase. This is safe
      // locally because debug tokens are not sent to prod services.
      self.FIREBASE_APPCHECK_DEBUG_TOKEN = true;
      appCheck = initializeAppCheck(app, { provider: new ReCaptchaV3Provider("debug"), isTokenAutoRefreshEnabled: true });
      log('Using emulators: App Check may be logged as DEBUG or skipped.');
      log('App Check: reCAPTCHA v3 enabled.');
    } else {
      // ---- App Check: reCAPTCHA v3 or DEBUG fallback ----
      if (siteKey) {
        appCheck = initializeAppCheck(app, {
          provider: new ReCaptchaV3Provider(siteKey),
          isTokenAutoRefreshEnabled: true
        });
        log("App Check: reCAPTCHA v3 enabled.");
        // Try a grecaptcha.execute timing for v3/enterprise (best-effort)
        try {
          if (window.grecaptcha && typeof window.grecaptcha.execute === 'function') {
            log('Attempting grecaptcha.execute to prime App Check...');
            window.grecaptcha.execute(siteKey, {action: 'validate'}).then(t => console.log('grecaptcha.execute token', t)).catch(e => console.warn('grecaptcha.execute failed', e));
          }
        } catch (e) { console.warn('grecaptcha.execute attempt error', e); }
      } else {
        // Debug mode (no site key needed)
        // If you want to register a debug token, open DevTools Console and copy the printed token.
        // Set FIREBASE_APPCHECK_DEBUG_TOKEN to true to enable the SDK's debug behavior.
        self.FIREBASE_APPCHECK_DEBUG_TOKEN = true;
        appCheck = initializeAppCheck(app, { provider: new ReCaptchaV3Provider("debug"), isTokenAutoRefreshEnabled: true });
        log("App Check: DEBUG token mode.");
        if (debugFlag) {
          try {
            // The SDK prints the debug token to console; also print to #out for the validator to capture
            const dbg = self.FIREBASE_APPCHECK_DEBUG_TOKEN || 'true';
            log('App Check DEBUG token (SDK may print a real value in devtools): ' + String(dbg));
          } catch (e) { console.warn('debug token print failed', e); }
        }
      }
    }

    // ---- Auth ----
    const auth = getAuth(app);
    try {
      if (firebaseConfig.useEmulators && firebaseConfig.emulatorPorts && firebaseConfig.emulatorPorts.auth) {
        const host = `http://localhost:${firebaseConfig.emulatorPorts.auth}`;
        console.log('Using Auth emulator:', host);
        connectAuthEmulator(auth, host, { disableWarnings: true });
        log('Connected Auth emulator at ' + host);
      }
    } catch (e) {
      console.warn('Emulator connect attempt failed', e);
    }

    if (!email || !pass) throw new Error("Missing credentials (?email=&pass=).");
    let cred = null;
    const delay = (ms) => new Promise(r => setTimeout(r, ms));
    // Try sign-in with retries; if user-not-found, attempt to create user in emulator and retry
    for (let attempt = 1; attempt <= 4; attempt++) {
      try {
        cred = await signInWithEmailAndPassword(auth, email, pass);
        console.log('Signed in as', cred.user?.email || '(unknown)');
        log(`Signed in as ${cred.user.email}`);
        break;
      } catch (e) {
        console.warn('Auth sign-in error', e?.message || e);
        log('Auth sign-in error ' + (e?.message || String(e)));
        // If user-not-found, try creating it (emulator-only safe operation)
        try {
          if (e && (e.code === 'auth/user-not-found' || String(e).toLowerCase().includes('user-not-found'))) {
            log('Creating test user in Auth emulator...');
            try { await createUserWithEmailAndPassword(auth, email, pass); log('Created test user'); } catch(e2) { log('User create failed: ' + (e2?.message || e2)); }
          }
        } catch (ee) { /* ignore */ }
      }
      // backoff before retrying
      await delay(300 * attempt);
    }
    // Fallback: if sign-in didn't return a cred but currentUser exists, use it
    if (!cred && auth.currentUser) {
      cred = { user: auth.currentUser };
      console.log('Signed in as', cred.user?.email || '(unknown)');
      log(`Signed in as ${cred.user.email}`);
    }
    if (!cred) {
      console.error('Failed to sign in after retries');
    }

    // ---- Tokens ----
    const idToken = await cred.user.getIdToken(/* forceRefresh */ true);
    log(`ID Token (preview): ${idToken ? idToken.substring(0,24) + '…' : 'none'}`);

    // Only attempt to fetch an App Check token when App Check was initialized
    let appCheckToken = null;
    if (typeof appCheck !== 'undefined' && appCheck) {
      try {
        appCheckToken = await getAppCheckToken(appCheck);
      } catch (e) {
        console.warn('getAppCheckToken failed', e);
      }
    }
    log(`AppCheck token (preview): ${appCheckToken?.token ? (appCheckToken.token.substring(0,24) + '…') : 'none'}`);

    // Final concise two-line output expected by the validator
    out.textContent = `ID Token: ${!!idToken}\nApp Check Token: ${!!appCheckToken?.token}`;
  } catch (e) {
    console.error(e);
    out.textContent = `ERROR: ${e?.message || e}`;
  }
</script>
