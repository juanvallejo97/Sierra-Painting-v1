rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ---- helpers -----------------------------------------------------------
    function authed() {
      return request.auth != null;
    }

    // Alias for authed() - used in timeclock rules
    function isSignedIn() {
      return authed();
    }

    // Return company_id claim or null
    function claimCompany() {
      return authed() && request.auth.token.company_id != null
        ? request.auth.token.company_id
        : null;
    }

    // Check the authenticated user's company matches the path
    function isCompany(companyId) {
      return claimCompany() == companyId;
    }

    // Role checks: Uses custom claims from Firebase Auth tokens
    // Custom claims should be set via setUserRole Cloud Function
    function hasAnyRole(roles) {
      return authed() &&
             request.auth.token.role != null &&
             request.auth.token.role in roles;
    }

    // Individual role checks
    function isAdmin() {
      return hasAnyRole(["admin"]);
    }

    function isManager() {
      return hasAnyRole(["manager"]);
    }

    function isStaff() {
      return hasAnyRole(["staff"]);
    }

    // Check if user is accessing their own document
    function isOwner(uid) {
      return authed() && request.auth.uid == uid;
    }

    // Alias for isOwner - used in users rules
    function isSelf(uid) {
      return isOwner(uid);
    }

    // Check if user owns the document being modified
    function isDocOwner() {
      return authed() && resource.data.ownerId == request.auth.uid;
    }

    // Only allow specific fields to change on self-edits
    function willOnlyChange(allowedKeys) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowedKeys);
    }

    // ---- company-scoped documents -----------------------------------------
    match /companies/{companyId} {
      // company document itself
      allow read: if authed() && isCompany(companyId);

      // all subcollections under a company (e.g., projects, jobs, estimatesâ€¦)
      match /{collection}/{docId} {
        // Everyone in the company can read
        allow read: if authed() && isCompany(companyId);

        // Creates: staff/admin OR owner creating their own doc
        allow create: if authed() && isCompany(companyId) && (
          hasAnyRole(["admin", "manager", "staff"]) ||
          request.resource.data.ownerId == request.auth.uid
        );

        // Updates/deletes: admin/manager OR owner with limited self fields
        allow update, delete: if authed() && isCompany(companyId) && (
          hasAnyRole(["admin", "manager"]) ||
          (isDocOwner() && willOnlyChange(["title","notes","status","images","updatedAt","hours"]))
        );
      }
    }

    match /companies/{companyId}/invoices/{doc} {
      allow read: if isCompany(companyId) && (isManager() || isAdmin());
      allow create, update, delete: if isCompany(companyId) && isAdmin();
    }

    match /companies/{companyId}/users/{uid} {
      allow read: if isCompany(companyId) && (isOwner(uid) || isAdmin());
      allow update: if isCompany(companyId) && (isOwner(uid) || isAdmin());
      allow create, delete: if isCompany(companyId) && isAdmin();
    }

    // /users/{uid}
    match /users/{uid} {
      allow read: if isSelf(uid);
      allow create: if isSelf(uid) && request.resource.data.keys().hasOnly(['displayName','email','photoURL','createdAt','updatedAt'])
        && request.time == request.resource.data.createdAt
        && request.resource.data.updatedAt == request.resource.data.createdAt;
      allow update: if isSelf(uid)
        && request.resource.data.keys().hasOnly(['displayName','photoURL','updatedAt'])
        && request.resource.data.updatedAt == request.time;
      allow delete: if false;
    }

    // /timeclockEntries/{entryId}
    match /timeclockEntries/{entryId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.resource.data.keys().hasOnly(['userId','jobId','clockIn','clockOut','notes','createdAt'])
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.clockIn is timestamp
        && (!('clockOut' in request.resource.data) || request.resource.data.clockOut is timestamp)
        && request.resource.data.createdAt == request.time;
      allow update: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasOnly(['clockOut','notes'])
        && (('clockOut' in request.resource.data) ? request.resource.data.clockOut is timestamp : true);
      allow delete: if false;
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
