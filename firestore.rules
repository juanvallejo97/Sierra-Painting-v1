rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ---- helpers -----------------------------------------------------------
    function authed() {
      return request.auth != null;
    }

    // Alias for authed() - used in timeclock rules
    function isSignedIn() {
      return authed();
    }

    // Return companyId claim or null
    function claimCompany() {
      return authed() && request.auth.token.companyId != null
        ? request.auth.token.companyId
        : null;
    }

    // Check the authenticated user's company matches the path
    function isCompany(companyId) {
      return claimCompany() == companyId;
    }

    // Role checks: Uses custom claims from Firebase Auth tokens
    // Custom claims should be set via setUserRole Cloud Function
    function hasAnyRole(roles) {
      return authed() &&
             request.auth.token.role != null &&
             request.auth.token.role in roles;
    }

    // Individual role checks
    function isAdmin() {
      return hasAnyRole(["admin"]);
    }

    function isManager() {
      return hasAnyRole(["manager"]);
    }

    // Check if user is accessing their own document
    function isOwner(uid) {
      return authed() && request.auth.uid == uid;
    }

    // Alias for isOwner - used in users rules
    function isSelf(uid) {
      return isOwner(uid);
    }

    // Check if user owns the document being modified
    function isDocOwner() {
      return authed() && resource.data.ownerId == request.auth.uid;
    }

    // Only allow specific fields to change on self-edits
    function willOnlyChange(allowedKeys) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowedKeys);
    }

    // ---- company-scoped documents -----------------------------------------
    match /companies/{companyId} {
      // company document itself
      allow read: if authed() && isCompany(companyId);

      // all subcollections under a company (e.g., projects, jobs, estimatesâ€¦)
      match /{collection}/{docId} {
        // Everyone in the company can read
        allow read: if authed() && isCompany(companyId);

        // Creates: staff/admin OR owner creating their own doc
        allow create: if authed() && isCompany(companyId) && (
          hasAnyRole(["admin", "manager", "staff"]) ||
          request.resource.data.ownerId == request.auth.uid
        );

        // Updates/deletes: admin/manager OR owner with limited self fields
        allow update, delete: if authed() && isCompany(companyId) && (
          hasAnyRole(["admin", "manager"]) ||
          (isDocOwner() && willOnlyChange(["title","notes","status","images","updatedAt","hours"]))
        );
      }
    }

    match /companies/{companyId}/invoices/{doc} {
      allow read: if isCompany(companyId) && (isManager() || isAdmin());
      allow create, update, delete: if isCompany(companyId) && isAdmin();
    }

    match /companies/{companyId}/users/{uid} {
      allow read: if isCompany(companyId) && (isOwner(uid) || isAdmin());
      allow update: if isCompany(companyId) && (isOwner(uid) || isAdmin());
      allow create, delete: if isCompany(companyId) && isAdmin();
    }

    // ---- Root-level collections with company isolation -----------------------

    // /estimates/{estimateId}
    // Estimates are stored at root level with companyId field for multi-tenant isolation
    match /estimates/{estimateId} {
      // Read: Anyone in the same company
      allow read: if authed()
        && resource.data.companyId == claimCompany();

      // Create: Admin/Manager only, must set correct companyId
      allow create: if authed()
        && hasAnyRole(["admin", "manager"])
        && request.resource.data.companyId == claimCompany()
        && request.resource.data.keys().hasAll(["companyId", "customerId", "status", "amount", "items", "validUntil"])
        && request.resource.data.status == "draft";

      // Update: Admin/Manager only, cannot change companyId or createdAt
      allow update: if authed()
        && hasAnyRole(["admin", "manager"])
        && resource.data.companyId == claimCompany()
        && request.resource.data.companyId == resource.data.companyId
        && (!request.resource.data.keys().hasAny(["createdAt"]) || request.resource.data.createdAt == resource.data.createdAt);

      // Delete: Admin only
      allow delete: if authed()
        && isAdmin()
        && resource.data.companyId == claimCompany();
    }

    // /invoices/{invoiceId}
    // Invoices are stored at root level with companyId field for multi-tenant isolation
    match /invoices/{invoiceId} {
      // Read: Anyone in the same company
      allow read: if authed()
        && resource.data.companyId == claimCompany();

      // Create: Admin/Manager only, must set correct companyId
      allow create: if authed()
        && hasAnyRole(["admin", "manager"])
        && request.resource.data.companyId == claimCompany()
        && request.resource.data.keys().hasAll(["companyId", "customerId", "status", "amount", "items", "dueDate"])
        && request.resource.data.status == "pending";

      // Update: Admin/Manager only, cannot change companyId or createdAt
      allow update: if authed()
        && hasAnyRole(["admin", "manager"])
        && resource.data.companyId == claimCompany()
        && request.resource.data.companyId == resource.data.companyId
        && (!request.resource.data.keys().hasAny(["createdAt"]) || request.resource.data.createdAt == resource.data.createdAt);

      // Delete: Admin only
      allow delete: if authed()
        && isAdmin()
        && resource.data.companyId == claimCompany();
    }

    // /customers/{customerId}
    // Customers are stored at root level with companyId field for multi-tenant isolation
    match /customers/{customerId} {
      // Read: Anyone in the same company
      allow read: if authed()
        && resource.data.companyId == claimCompany();

      // Create: Admin/Manager/Staff, must set correct companyId
      allow create: if authed()
        && hasAnyRole(["admin", "manager", "staff"])
        && request.resource.data.companyId == claimCompany()
        && request.resource.data.keys().hasAll(["companyId", "name"]);

      // Update: Admin/Manager/Staff, cannot change companyId or createdAt
      allow update: if authed()
        && hasAnyRole(["admin", "manager", "staff"])
        && resource.data.companyId == claimCompany()
        && request.resource.data.companyId == resource.data.companyId
        && (!request.resource.data.keys().hasAny(["createdAt"]) || request.resource.data.createdAt == resource.data.createdAt);

      // Delete: Admin/Manager only
      allow delete: if authed()
        && hasAnyRole(["admin", "manager"])
        && resource.data.companyId == claimCompany();
    }

    // /jobs/{jobId}
    // Jobs define work sites with geofence parameters
    match /jobs/{jobId} {
      // Read: Anyone in the same company
      allow read: if authed()
        && resource.data.companyId == claimCompany();

      // Create: Admin/Manager only
      allow create: if authed()
        && hasAnyRole(["admin", "manager"])
        && request.resource.data.companyId == claimCompany()
        && request.resource.data.keys().hasAll(["companyId", "name", "address"]);

      // Update: Admin/Manager only, cannot change companyId
      allow update: if authed()
        && hasAnyRole(["admin", "manager"])
        && resource.data.companyId == claimCompany()
        && request.resource.data.companyId == resource.data.companyId;

      // Delete: Admin only
      allow delete: if authed()
        && isAdmin()
        && resource.data.companyId == claimCompany();
    }

    // /assignments/{assignmentId}
    // Worker-to-job assignments for access control
    match /assignments/{assignmentId} {
      // Read: Anyone in the same company
      allow read: if authed()
        && resource.data.companyId == claimCompany();

      // Create/Update/Delete: Admin/Manager only
      allow create, update, delete: if authed()
        && hasAnyRole(["admin", "manager"])
        && (
          // On create, must set companyId
          (request.resource.data.companyId == claimCompany()) ||
          // On update/delete, existing must match
          (resource.data.companyId == claimCompany())
        );
    }

    // /time_entries/{entryId}
    // CRITICAL SECURITY BOUNDARY: Hardened Rules (v2.0)
    //
    // DESIGN RATIONALE:
    // - Workers cannot manipulate their own time (prevents fraud)
    // - Geofence validation happens server-side only (cannot be bypassed)
    // - Clock In/Out go through Cloud Functions (clockIn/clockOut)
    // - Cloud Functions use Admin SDK (bypasses these rules)
    //
    // IMMUTABILITY GUARANTEE:
    // - Core fields (companyId, userId, jobId, clockInAt, clockInGeofenceValid) are IMMUTABLE after create
    // - Only clockOut* fields and notes can be updated
    // - This prevents tampering with time records
    //
    // READ PERMISSIONS:
    // - Workers: Can read only their own entries from their company
    // - Admins/Managers: Can read all entries from their company
    //
    match /time_entries/{entryId} {
      // Read: Anyone in same company (must have companyId claim)
      allow read: if authed() && claimCompany() == resource.data.companyId;

      // Create: Must be for self; cannot set clockOut* at create (prevents pre-clocking out)
      allow create: if authed()
        && claimCompany() == request.resource.data.companyId
        && request.resource.data.userId == request.auth.uid
        && !request.resource.data.keys().hasAny(['clockOutAt','clockOutGeofenceValid','clockOutLocation']);

      // Update: Only owner may close; core fields are IMMUTABLE
      allow update: if authed()
        && claimCompany() == resource.data.companyId
        && resource.data.userId == request.auth.uid
        && request.resource.data.companyId == resource.data.companyId
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.jobId == resource.data.jobId
        && request.resource.data.clockInAt == resource.data.clockInAt
        && request.resource.data.clockInGeofenceValid == resource.data.clockInGeofenceValid
        && (request.resource.data.diff(resource.data).changedKeys()
            .hasOnly(['clockOutAt','clockOutGeofenceValid','clockOutLocation','updatedAt','notes']));

      // Delete: NO client deletes (admin uses Cloud Functions)
      allow delete: if false;
    }

    // /clockEvents/{id}
    // Workers post clock events here; Cloud Function validates & creates timeEntries
    match /clockEvents/{id} {
      // Read: Workers can read their own events; Admins can read all
      allow read: if authed() && (
        (hasAnyRole(["admin","manager"]) && resource.data.companyId == claimCompany()) ||
        (resource.data.userId == request.auth.uid && resource.data.companyId == claimCompany())
      );

      // Create: Workers can create their own clock events
      allow create: if authed()
        && request.resource.data.companyId == claimCompany()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(["companyId","userId","jobId","type","clientEventId"]);

      // Prevent edits/deletes by clients (events are append-only)
      allow update, delete: if false;
    }

    // /users/{uid}
    match /users/{uid} {
      allow read: if isSelf(uid);
      allow create: if isSelf(uid) && request.resource.data.keys().hasOnly(['displayName','email','photoURL','createdAt','updatedAt'])
        && request.time == request.resource.data.createdAt
        && request.resource.data.updatedAt == request.resource.data.createdAt;
      allow update: if isSelf(uid)
        && request.resource.data.keys().hasOnly(['displayName','photoURL','updatedAt'])
        && request.resource.data.updatedAt == request.time;
      allow delete: if false;
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
